<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<title>EloCalc</title>
	<style>
		:root {
			--primary: #005dac;
			--on-primary: #ffffff;
			--hover: #00539a;
			--background: #f9f9ff;
			--surface: #ffffff;
			--text: #181c21;
			--border: #c1c6d4;
			--muted: #f2f3fc;
			--success: #0b6b1d;
			--on-success: #ffffff;
			--danger: #ba1a1a;
			--on-danger: #ffffff;
			--highlight-bg: #d4e3ff;
		}
		@media (prefers-color-scheme: dark) {
			:root:not(.light) {
				--primary: #a5c8ff;
				--on-primary: #00315f;
				--hover: #72adff;
				--background: #101319;
				--surface: #0b0e14;
				--text: #e0e2ea;
				--border: #414752;
				--muted: #181c21;
				--success: #82db7e;
				--on-success: #00390a;
				--danger: #ffb4ab;
				--on-danger: #93000a;
				--highlight-bg: #001c3a;
			}
		}
		:root.dark {
			--primary: #a5c8ff;
			--on-primary: #00315f;
			--hover: #72adff;
			--background: #101319;
			--surface: #0b0e14;
			--text: #e0e2ea;
			--border: #414752;
			--muted: #181c21;
			--success: #82db7e;
			--on-success: #00390a;
			--danger: #ffb4ab;
			--on-danger: #93000a;
			--highlight-bg: #001c3a;
		}
		* { 
			box-sizing: border-box; 
			margin: 0; 
			padding: 0; 
			outline-offset: 2px; 
		}
		*:focus-visible { 
			outline: 2px solid var(--primary); 
		}
		body {
			background: var(--background);
			color: var(--text);
			font-family: sans-serif;
			display: flex;
			justify-content: center;
			min-height: 100vh;
			padding: 1rem;
		}
		.container {
			background: var(--surface);
			border: 1px solid var(--border);
			border-radius: 8px;
			max-width: 960px;
			padding: 2rem;
			width: 100%;
			position: relative;
			margin: 2rem 0;
		}
		.hidden { 
			display: none !important; 
		}
		h1, h2, h3, label { 
			margin: .5rem 0; 
		}
		label { 
			display: block; 
			font-weight: 700; 
		}
		input, select, button {
			background: var(--surface);
			border: 1px solid var(--border);
			border-radius: 4px;
			color: var(--text);
			font-size: 1rem;
			padding: .5rem;
			width: 100%;
		}
		button { 
			cursor: pointer; 
		}
		button:disabled { 
			opacity: .6; 
			cursor: not-allowed; 
		}
		.primary { 
			background: var(--primary); 
			color: var(--on-primary); 
			border: 0; 
		}
		.primary:hover:not(:disabled) { 
			background: var(--hover); 
		}
		.secondary:hover:not(:disabled) { 
			background: var(--muted); 
		}
		.danger, .success { 
			color: var(--on-danger); 
			border: 0; 
			background: var(--danger); 
		}
		.success { 
			background: var(--success); 
			color: var(--on-success); 
		}
		.danger:hover, .success:hover { 
			filter: brightness(.9); 
		}
		.selectors {
			position: absolute;
			right: 2rem;
			top: 1rem;
			display: flex;
			gap: 8px;
		}
		.selectors select { 
			width: auto; 
			font-size: .9rem; 
		}
		.mode-elo .win-input, .mode-elo .tie-input, .mode-elo #headWin, .mode-elo #headTie, .mode-elo #allowTies, .mode-elo #allowTiesLabel, .mode-elo .group { 
			display: none !important; 
		}
		.mode-win #normalizeElo, .mode-win #normalizeEloLabel { 
			display: none !important; 
		}
		.mode-win .elo-input, .mode-win #mainElo, .mode-win #headElo { 
			display: none !important; 
		}
		#mainElo { 
			margin-top: 0.5rem; 
		}
		.row { 
			display: flex; 
			gap: 1rem; 
			margin-bottom: 1rem; 
		}
		.group { 
			flex: 1; 
		}
		.competitor-row { 
			display: flex; 
			gap: .5rem; 
			align-items: center; 
			margin-bottom: .5rem; 
		}
		.competitor-row input[type=text] { 
			flex: 2; 
		}
		.competitor-row input[type=number] { 
			flex: 1; 
		}
		.competitor-row button { 
			width: auto; 
			padding: .5rem 1rem; 
		}
		table { 
			border-collapse: collapse; 
			margin-top: 1rem; 
			width: 100%; 
			font-size: .9rem; 
		}
		th, td { 
			border: 1px solid var(--border); 
			padding: .5rem; 
			text-align: left; 
		}
		th { 
			background: var(--primary); 
			color: var(--on-primary); 
			position: sticky; 
			top: 0; 
			z-index: 5; 
			cursor: pointer; 
			user-select: none; 
		}
		th:hover { 
			background: var(--hover); 
		}
		th::after { 
			content: ''; 
			display: inline-block; 
			margin-left: 5px; 
			width: 0.8em; 
			opacity: 0.7; 
		}
		th.sort-asc::after { 
			content: '▲'; 
		}
		th.sort-desc::after { 
			content: '▼'; 
		}
		.error { 
			color: var(--danger); 
			font-size: .9rem; 
			margin: 1rem 0; 
			display: block; 
			font-weight: 500; 
		}
		.info { 
			font-size: .9rem; 
			opacity: .8; 
			line-height: 1.6; 
			margin-bottom: 1rem; 
		}
		.bar-container { 
			background: var(--muted); 
			border-radius: 4px; 
			height: 8px; 
			min-width: 80px; 
			width: 100%; 
			overflow: hidden; 
		}
		.bar { 
			background: var(--primary); 
			height: 100%; 
		}
		.actions { 
			display: flex; 
			gap: 1rem; 
			margin-top: 1rem; 
		}
		.table-wrapper { 
			overflow-x: auto; 
			-webkit-overflow-scrolling: touch; 
			max-height: 70vh; 
			overflow-y: auto; 
			border-bottom: 1px solid var(--border); 
		}
		.highlight { 
			background-color: var(--highlight-bg); 
		}
		.avg-highlight { 
			outline: 2px dashed var(--primary); 
			outline-offset: -2px; 
		}
		input:out-of-range, .invalid { 
			border-color: var(--danger); 
			background-color: var(--background); 
		}
		#listHeaders { 
			position: sticky; 
			top: 0; 
			z-index: 10; 
			background: var(--surface); 
			padding: .75rem 0; 
			border-bottom: 1px solid var(--border); 
			margin-bottom: .5rem; 
		}
		.options-row { 
			align-items: center; 
			margin-top: 1rem; 
			gap: .5rem; 
		}
		#allowTies { 
			width: auto; 
		}
		#allowTiesLabel { 
			margin: 0; 
		}
		#competitorsHeader { 
			margin-top: 1.5rem; 
		}
		#headName { 
			flex: 2; 
			font-size: .85rem; 
			opacity: .8; 
		}
		#headWin, #headTie { 
			flex: 1; 
			font-size: .85rem; 
			opacity: .8; 
		}
		.hidden-btn { 
			visibility: hidden; 
			cursor: default; 
		}
		#list { 
			margin-bottom: 1rem; 
		}
		.controls-row { 
			gap: .5rem; 
		}
		#add, #clear, #import, #edit, #copy, #export { 
			flex: 1; 
		}
		@media(max-width: 768px) {
			.selectors { 
				position: static; 
				justify-content: end; 
				margin-bottom: .5rem; 
			}
			.row { 
				flex-direction: column; 
			}
		}
	</style>
</head>
<body>
	<div class="container">
		<div class="selectors">
			<select id="mode">
				<option value="win">Win Rate -> Elo</option>
				<option value="elo">Elo -> Win Rate</option>
			</select>
			<select id="language"><option value="en">English</option><option value="id">Bahasa Indonesia</option></select>
			<select id="theme"><option value="auto"></option><option value="light"></option><option value="dark"></option></select>
		</div>
		<h1 id="title"></h1>
		<p id="subtitle" class="info"></p>
		<div id="input">
			<div class="group">
				<label id="mainLabel" for="mainName"></label>
				<input type="text" id="mainName" value="Player A">
				<input type="number" id="mainElo" placeholder="Elo" class="elo-input">
			</div>
			<div class="row options-row">
				<input type="checkbox" id="allowTies">
				<label for="allowTies" id="allowTiesLabel"></label>
				<input type="checkbox" id="normalizeElo">
				<label for="normalizeElo" id="normalizeEloLabel"></label>
			</div>
			<h3 id="competitorsHeader"></h3>
			<div id="listHeaders" class="competitor-row">
				<label id="headName"></label>
				<label id="headWin"></label>
				<label id="headTie"></label>
				<label id="headElo"></label>
				<button class="hidden-btn" aria-hidden="true">×</button>
			</div>
			<div id="list"></div>
			<div class="row controls-row">
				<button id="add" class="secondary"></button>
				<button id="clear" class="secondary"></button>
				<button id="import" class="secondary"></button>
			</div>
			<input type="file" id="file" accept=".csv,.tsv,.txt" class="hidden">
			<span id="error" class="error hidden" aria-live="polite"></span>
			<button id="calculate" class="primary"></button>
		</div>
		<div id="results" class="hidden">
			<div class="actions">
				<button id="edit" class="secondary"></button>
				<button id="copy" class="secondary"></button>
				<button id="export" class="success"></button>
			</div>
			<div id="resultsTable"></div>
		</div>
	</div>
	<script>
		const text = {
			en: {
				title: 'EloCalc',
				subtitle: 'Convert between Win Rates and Elo Ratings',
				autoTheme: 'Auto Theme',
				lightTheme: 'Light',
				darkTheme: 'Dark',
				mainLabel: 'Main Contender',
				allowTiesLabel: 'Include Tie Rates',
				normalizeEloLabel: 'Normalize to 1000',
				competitorsHeader: 'Competitors',
				add: '+ Add Competitor',
				calculate: 'Calculate',
				edit: 'Edit Inputs',
				export: 'Export to CSV',
				copy: 'Copy Table',
				copySuccess: 'Copied!',
				import: 'Import CSV',
				clear: 'Clear All',
				clearConfirm: 'Are you sure you want to clear all competitors?',
				removeCompetitor: 'Remove Competitor',
				competitorPlaceholder: 'Competitor Name',
				winRatePlaceholder: 'Win % vs Main',
				tieRatePlaceholder: 'Tie % vs Main',
				eloPlaceholder: 'Elo Rating',
				alertCompetitors: 'Please add at least one competitor.',
				alertInvalidRate: 'Win rate and tie rate must be between 0-100, and their sum cannot exceed 100.',
				name: 'Name',
				winRate: 'Win Rate',
				tieRate: 'Tie Rate',
				effectiveScore: 'Expected Score',
				eloRating: 'Elo Rating',
				eloDifference: 'Elo Diff',
				relativeStrength: 'Relative Strength',
				resultsTitle: 'Results',
				infoText: 'Click any row to set it as the baseline. The 400-point rule: A 400-point difference equals ~91% expected win rate.',
				alertImport: 'Error importing file. Please ensure it is a valid CSV/TSV.',
				languageLabel: 'Language',
				themeLabel: 'Theme',
				modeLabel: 'Mode',
				modeWin: 'Win Rate -> Elo',
				modeElo: 'Elo -> Win Rate',
				rank: '#'
			},
			id: {
				title: 'EloCalc',
				subtitle: 'Konversi antara Tingkat Kemenangan dan Peringkat Elo',
				autoTheme: 'Tema Otomatis',
				lightTheme: 'Terang',
				darkTheme: 'Gelap',
				mainLabel: 'Pesaing Utama',
				allowTiesLabel: 'Sertakan Tingkat Seri',
				normalizeEloLabel: 'Normalisasi ke 1000',
				competitorsHeader: 'Kompetitor',
				add: '+ Tambah Kompetitor',
				calculate: 'Hitung',
				edit: 'Ubah Input',
				export: 'Ekspor ke CSV',
				copy: 'Salin Tabel',
				copySuccess: 'Tersalin!',
				import: 'Impor CSV',
				clear: 'Hapus Semua',
				clearConfirm: 'Apakah Anda yakin ingin menghapus semua kompetitor?',
				removeCompetitor: 'Hapus Kompetitor',
				competitorPlaceholder: 'Nama Kompetitor',
				winRatePlaceholder: 'Menang % vs Utama',
				tieRatePlaceholder: 'Seri % vs Utama',
				eloPlaceholder: 'Peringkat Elo',
				alertCompetitors: 'Harap tambahkan setidaknya satu kompetitor.',
				alertInvalidRate: 'Tingkat menang dan seri harus antara 0-100, dan jumlahnya tidak boleh melebihi 100.',
				name: 'Nama',
				winRate: 'Menang %',
				tieRate: 'Seri %',
				effectiveScore: 'Skor Harapan',
				eloRating: 'Peringkat Elo',
				eloDifference: 'Selisih Elo',
				relativeStrength: 'Kekuatan Relatif',
				resultsTitle: 'Hasil',
				infoText: 'Klik baris mana saja untuk menjadikannya acuan. Aturan 400 poin: Selisih 400 poin setara dengan ~91% tingkat menang yang diharapkan.',
				alertImport: 'Gagal mengimpor file. Pastikan format CSV/TSV valid.',
				languageLabel: 'Bahasa',
				themeLabel: 'Tema',
				modeLabel: 'Mode',
				modeWin: 'Tingkat Menang -> Elo',
				modeElo: 'Elo -> Tingkat Menang',
				rank: '#'
			}
		};
		const elements = new Proxy({}, { get: (_, id) => document.getElementById(id) });
		const escape = string => string.replace(/[&<>"']/g, char => '&#' + char.charCodeAt(0) + ';');

		const parseCSV = text => {
			const firstLine = text.split('\n')[0];
			let commas = 0, tabs = 0, inside = false;
			for (const char of firstLine) {
				if (char === '"') inside = !inside;
				else if (!inside) { if (char === ',') commas++; else if (char === '\t') tabs++; }
			}
			const separator = tabs >= commas && tabs > 0 ? '\t' : ',';
			const rows = [];
			let currentRow = [], currentCell = '';
			let insideQuote = false;

			for (let index = 0; index < text.length; index++) {
				const char = text[index];
				const nextChar = text[index + 1];
				if (char === '"') insideQuote = !insideQuote;
				if (char === separator && !insideQuote) {
					currentRow.push(currentCell);
					currentCell = '';
				} else if ((char === '\n' || char === '\r') && !insideQuote) {
					if (char === '\r' && nextChar === '\n') index++;
					currentRow.push(currentCell);
					if (currentRow.length > 1 || currentRow[0].trim()) rows.push(currentRow);
					currentRow = [];
					currentCell = '';
				} else {
					currentCell += char;
				}
			}
			if (currentCell || currentRow.length) {
				currentRow.push(currentCell);
				if (currentRow.length > 1 || currentRow[0].trim()) rows.push(currentRow);
			}
			return rows.map(row => row.map(cell => cell.trim().replace(/^"|"$/g, '').replace(/""/g, '"')));
		};

		class EloCalc {
			constructor() {
				this.competitors = Object.entries({
					'Player B': [65, 10, 1000],
					'Player C': [45, 15, 1200],
					'Player D': [30, 20, 800]
				}).map(([name, [winRate, tieRate, elo]], index) => ({ id: index + 1, name, winRate, tieRate, elo }));
				this.nextIndex = 4;
				this.data = null;
				this.allowTies = true;
				this.normalizeElo = false;
				this.mode = 'win';
				this.sortState = { field: 'eloRating', direction: -1 };
				this.setup();
				this.theme('auto');
				this.language = navigator.language?.startsWith('id') ? 'id' : 'en';
				this.lang(this.language);
				this.setMode('win');
			}

			setup() {
				const handlers = {
					add: () => this.add(),
					clear: () => this.clear(),
					calculate: () => this.calculate(),
					edit: () => this.display('input'),
					copy: () => this.copy(),
					export: () => this.export(),
					import: () => elements.file.click()
				};
				Object.entries(handlers).forEach(([id, handler]) => elements[id].onclick = handler);
				elements.file.onchange = event => this.load(event.target.files[0]);
				elements.input.oninput = event => {
					this.error();
					if (event.target.matches('.win-input, .tie-input')) this.validateRow(event.target.closest('.competitor-row'));
				};
				elements.language.onchange = event => this.lang(event.target.value);
				elements.theme.onchange = event => this.theme(event.target.value);
				elements.mode.onchange = event => this.setMode(event.target.value);
				elements.allowTies.onchange = event => {
					this.allowTies = event.target.checked;
					elements.headTie.classList.toggle('hidden', !this.allowTies);
					document.querySelectorAll('.tie-input').forEach(el => el.classList.toggle('hidden', !this.allowTies));
					document.querySelectorAll('.competitor-row').forEach(row => this.validateRow(row));
				};
				elements.allowTies.checked = this.allowTies;
				elements.normalizeElo.onchange = event => { this.normalizeElo = event.target.checked; this.calculate(); };
				elements.normalizeElo.checked = this.normalizeElo;
				document.onkeydown = event => this.key(event);
				elements.resultsTable.addEventListener('click', event => this.handleTableClick(event));
				elements.resultsTable.addEventListener('keydown', event => this.handleTableKey(event));
				elements.list.onclick = event => {
					const row = event.target.closest('.competitor-row');
					if (event.target.matches('.danger') && row) this.remove(+row.dataset.id);
				};
				elements.list.onchange = event => {
					const row = event.target.closest('.competitor-row');
					const competitor = row && this.competitors.find(c => c.id === +row.dataset.id);
					if (competitor) this.updateCompetitor(competitor, event.target);
				};
			}

			key(event) {
				if (event.key !== 'Enter') return;
				if (event.ctrlKey || event.metaKey) { this.calculate(); return; }
				if (event.target.matches('input') && event.target.closest('.competitor-row')) {
					event.preventDefault();
					const row = event.target.closest('.competitor-row');
					const competitor = this.competitors.find(c => c.id === +row.dataset.id);
					if (competitor) this.updateCompetitor(competitor, event.target);
					this.focusNext(event.target, row);
				} else if (event.target.matches('#mainName, #allowTies')) {
					event.preventDefault();
					const firstInput = elements.list.firstElementChild?.querySelector('input');
					if (firstInput) firstInput.focus();
					else elements.add.focus();
				}
			}

			handleTableClick(event) {
				const header = event.target.closest('th[data-sort]');
				if (header) { this.sortResults(header.dataset.sort); return; }
				const row = event.target.closest('tr[data-id]');
				if (row) this.setBaseline(row.dataset.id);
			}

			handleTableKey(event) {
				if (event.key !== 'Enter' && event.key !== ' ') return;
				const header = event.target.closest('th[data-sort]');
				if (header) { event.preventDefault(); this.sortResults(header.dataset.sort); return; }
				const row = event.target.closest('tr[data-id]');
				if (row) { event.preventDefault(); this.setBaseline(row.dataset.id); }
			}

			updateCompetitor(competitor, target) {
				const value = target.value;
				if (target.classList.contains('name-input')) competitor.name = value;
				else if (target.classList.contains('win-input')) this.updateRate(competitor, 'winRate', value, target);
				else if (target.classList.contains('tie-input')) this.updateRate(competitor, 'tieRate', value, target);
				else if (target.classList.contains('elo-input')) this.updateRate(competitor, 'elo', value, target);
			}

			updateRate(competitor, property, value, target) {
				const number = value === '' ? '' : (parseFloat(value) || 0);
				competitor[property] = number;
			}

			focusNext(target, row) {
				if (target.type === 'text') target.nextElementSibling?.focus();
				else if (target.classList.contains('win-input') && this.allowTies) target.nextElementSibling?.focus();
				else if (row.nextElementSibling) row.nextElementSibling.querySelector('input')?.focus();
				else this.add();
			}

			string(key) { return text[this.language]?.[key] ?? key; }
			format(value, options = {}) { return value.toLocaleString(this.language === 'id' ? 'id-ID' : 'en-US', options); }

			theme(themeName) {
				document.documentElement.className = themeName === 'auto' ? '' : themeName;
				elements.theme.value = themeName;
			}

			lang(language) {
				this.language = elements.language.value = document.documentElement.lang = language;
				Object.keys(text.en).forEach(key => { if (elements[key]) elements[key].textContent = this.string(key); });
				this.updateLabels();
				[...elements.theme.options].forEach(option => option.textContent = this.string(option.value + 'Theme'));
				[['language', 'languageLabel'], ['theme', 'themeLabel'], ['mode', 'modeLabel']].forEach(([id, key]) => elements[id].setAttribute('aria-label', this.string(key)));
				this.renderCompetitors();
				if (!elements.results.classList.contains('hidden') && this.data) this.renderResults();
			}

			setMode(mode) {
				this.mode = mode;
				elements.input.className = `mode-${mode}`;
				elements.mode.value = mode;
				this.error();
				this.renderCompetitors();
			}

			updateLabels() {
				elements.headName.textContent = this.string('name');
				elements.headWin.textContent = this.string('winRatePlaceholder');
				elements.headTie.textContent = this.string('tieRatePlaceholder');
				elements.headElo.textContent = this.string('eloPlaceholder');
				[...elements.mode.options].forEach(option => option.textContent = this.string(option.value === 'win' ? 'modeWin' : 'modeElo'));
			}

			display(section) {
				['input', 'results'].forEach(id => elements[id].classList.toggle('hidden', id !== section));
				if (section === 'results') { elements.results.setAttribute('tabindex', '-1'); elements.results.focus(); }
				else elements.mainName.focus();
			}

			error(message) {
				elements.error.textContent = message || '';
				elements.error.classList.toggle('hidden', !message);
			}

			add() {
				this.error();
				this.competitors.push({ id: this.nextIndex++, name: '', winRate: '', tieRate: '', elo: '' });
				this.renderCompetitors();
				elements.list.lastElementChild?.querySelector('input')?.focus();
			}

			clear() {
				if (confirm(this.string('clearConfirm'))) {
					this.competitors = [];
					this.renderCompetitors();
					this.add();
					this.error();
				}
			}

			remove(id) {
				this.error();
				const index = this.competitors.findIndex(c => c.id === id);
				this.competitors = this.competitors.filter(c => c.id !== id);
				this.renderCompetitors();
				const target = Math.min(index, this.competitors.length - 1);
				if (target >= 0) elements.list.children[target]?.querySelector('.danger')?.focus();
				else elements.add.focus();
			}

			renderCompetitors() {
				elements.headTie.classList.toggle('hidden', !this.allowTies);
				elements.list.innerHTML = this.competitors.map((competitor, index) => {
					const invalid = this.isInvalid(competitor) ? 'invalid' : '';
					return `<div class="competitor-row" data-id="${competitor.id}">
						<input type="text" class="name-input" value="${escape(competitor.name)}" placeholder="${this.string('competitorPlaceholder')}" aria-label="${this.string('competitorPlaceholder')} ${index + 1}">
						<input type="number" class="win-input ${invalid}" value="${competitor.winRate}" placeholder="${this.string('winRatePlaceholder')}" min="0" max="100" step="0.1" aria-label="${this.string('winRatePlaceholder')} ${index + 1}">
						<input type="number" class="tie-input ${this.allowTies ? '' : 'hidden'} ${invalid}" value="${competitor.tieRate}" placeholder="${this.string('tieRatePlaceholder')}" min="0" max="100" step="0.1" aria-label="${this.string('tieRatePlaceholder')} ${index + 1}">
						<input type="number" class="elo-input" value="${competitor.elo}" placeholder="${this.string('eloPlaceholder')}" aria-label="${this.string('eloPlaceholder')} ${index + 1}">
						<button class="danger" aria-label="${this.string('removeCompetitor')} ${index + 1}">×</button>
					</div>`;
				}).join('');
			}

			load(file) {
				const reader = new FileReader();
				reader.onload = event => {
					try {
						const rows = parseCSV(event.target.result);
						if (!rows.length) throw new Error();

						const header = rows[0];
						const find = regex => header.findIndex(cell => regex.test(cell));
						let nameIndex = find(/name|nama/i);
						let winIndex = find(/win|menang/i);
						let tieIndex = find(/tie|seri/i);

						if (nameIndex < 0 || winIndex < 0) {
							nameIndex = 0;
							winIndex = 1;
							const isAllNumbers = header.every(cell => /^\d+$/.test(cell.replace(/[.,]/g, '').trim()));
							if (isAllNumbers) {
								winIndex = header.findIndex(cell => /^\d+$/.test(cell.replace(/[.,]/g, '').trim()));
								nameIndex = 1 - winIndex;
							}
						}

						if (nameIndex < 0 || winIndex < 0) throw new Error();

						const isWinNum = !isNaN(parseFloat((header[winIndex] || '').replace(',', '.')));
						const hasHeader = (find(/name|nama/i) >= 0 || find(/win|menang/i) >= 0) || !isWinNum;

						const competitors = (hasHeader ? rows.slice(1) : rows).map(cells => {
							if (!cells[nameIndex]) return null;
							const winRate = +((cells[winIndex] || '').replace(/,/g, '.').replace(/[^\d.]/g, '')) || 0;
							const tieRate = tieIndex >= 0 ? (+((cells[tieIndex] || '').replace(/,/g, '.').replace(/[^\d.]/g, '')) || 0) : 0;
							return { id: this.nextIndex++, name: cells[nameIndex], winRate, tieRate };
						}).filter(Boolean);

						if (!competitors.length) throw new Error();

						this.competitors = competitors;
						if (tieIndex >= 0) { this.allowTies = true; elements.allowTies.checked = true; }
						this.error();
						this.renderCompetitors();
						elements.file.value = '';
					} catch {
						this.error(this.string('alertImport'));
					}
				};
				if (file) reader.readAsText(file);
			}

			calculate() {
				this.error();
				const mainName = elements.mainName.value.trim() || 'Main';

				this.competitors = this.competitors.filter(c =>
					c.name.trim() ||
					(this.mode === 'win' && (c.winRate > 0 || c.tieRate > 0)) ||
					(this.mode === 'elo' && c.elo !== '')
				);
				this.renderCompetitors();

				let error = !this.competitors.length ? 'alertCompetitors' : null;
				if (!error && this.mode === 'win' && this.hasInvalidRates()) error = 'alertInvalidRate';

				if (error) this.error(this.string(error));
				else this.performCalculation(mainName);
			}

			hasInvalidRates() {
				return this.competitors.some(competitor => {
					const tieRate = this.allowTies ? +competitor.tieRate : 0;
					const winRate = +competitor.winRate;
					return winRate < 0 || winRate > 100 || tieRate < 0 || tieRate > 100 || winRate + tieRate > 100;
				});
			}

			performCalculation(mainName) {
				let allResults = [];
				let baselineId = 'main';
				let averageElo = 0;

				if (this.mode === 'win') {
					const rawResults = this.competitors.map(competitor => this.calculateRow(competitor));
					allResults = [{ name: mainName, rawElo: 0, isMain: true, id: 'main', winRate: 50, tieRate: 0 }, ...rawResults];
					averageElo = allResults.reduce((sum, result) => sum + result.rawElo, 0) / allResults.length;
					const adjustment = 1000 - averageElo;
					allResults.forEach(result => result.eloRating = result.rawElo + adjustment);
				} else {
					allResults = this.competitors.map(c => ({ name: c.name.trim() || `Competitor ${c.id}`, eloRating: parseFloat(c.elo) || 0, id: c.id }));
					if (allResults.length > 0) {
						averageElo = allResults.reduce((sum, result) => sum + result.eloRating, 0) / allResults.length;
						if (this.normalizeElo) {
							const adjustment = 1000 - averageElo;
							allResults.forEach(result => result.eloRating += adjustment);
							averageElo = 1000;
						}
						baselineId = allResults[0].id;
					}
				}

				const targetAverage = (this.mode === 'win' || this.normalizeElo) ? 1000 : averageElo;
				let closestId = null;
				let minDifference = Infinity;

				allResults.forEach(result => {
					const difference = Math.abs(result.eloRating - targetAverage);
					if (difference < minDifference) { minDifference = difference; closestId = result.id; }
				});

				this.data = {
					results: allResults.sort((a, b) => b.eloRating - a.eloRating),
					allowTies: this.allowTies,
					baselineId: this.data?.baselineId && allResults.find(r => r.id === this.data.baselineId) ? this.data.baselineId : baselineId,
					closestId
				};
				this.sortState = { field: 'eloRating', direction: -1 };
				this.renderResults();
				this.display('results');
			}

			calculateRow(competitor) {
				const tieRate = this.allowTies ? +competitor.tieRate : 0;
				const effectiveScore = (+competitor.winRate + tieRate * 0.5) / 100;

				const eloDifference = effectiveScore >= 1 ? 2000 :
				                    effectiveScore <= 0 ? -2000 :
				                    -400 * Math.log10(1 / effectiveScore - 1);

				return {
					name: competitor.name.trim() || `Competitor ${competitor.id}`,
					rawElo: eloDifference,
					id: competitor.id,
					winRate: +competitor.winRate,
					tieRate
				};
			}

			calculateRowStats(result, baselineCompetitor) {
				const eloDifference = result.eloRating - baselineCompetitor.eloRating;
				const effectiveScore = 1 / (1 + Math.pow(10, -eloDifference / 400));
				return { eloDifference, effectiveScore };
			}

			isInvalid(competitor) {
				if (this.mode === 'elo') return false;
				const tieRate = this.allowTies ? +competitor.tieRate : 0;
				return (+competitor.winRate + tieRate) > 100;
			}

			validateRow(row) {
				if (!row || this.mode === 'elo') {
					if (row) row.querySelectorAll('input').forEach(input => input.classList.remove('invalid'));
					return;
				}
				const winInput = row.querySelector('.win-input');
				const tieInput = row.querySelector('.tie-input');
				if (!winInput || !tieInput) return;

				const competitor = { winRate: winInput.value, tieRate: tieInput.value };
				const invalid = this.isInvalid(competitor);

				winInput.classList.toggle('invalid', invalid);
				tieInput.classList.toggle('invalid', invalid && this.allowTies);
			}

			sortResults(field) {
				if (this.sortState.field === field) this.sortState.direction *= -1;
				else { this.sortState.field = field; this.sortState.direction = field === 'name' ? 1 : -1; }
				this.renderResults();
			}

			renderResults() {
				if (!this.data) return;
				const { results, baselineId } = this.data;
				const baselineCompetitor = results.find(r => r.id === baselineId) || results[0];

				let calculatedResults = results.map((result, index) => {
					const { eloDifference, effectiveScore } = this.calculateRowStats(result, baselineCompetitor);
					return {
						...result,
						rank: index + 1,
						eloDifference,
						effectiveScore,
						displayWinRate: this.mode === 'win' ? result.winRate : effectiveScore * 100
					};
				});

				const { field, direction } = this.sortState;
				calculatedResults.sort((a, b) => {
					const valueA = a[field];
					const valueB = b[field];
					if (typeof valueA === 'string') return direction * valueA.localeCompare(valueB);
					return direction * (valueA - valueB);
				});

				const maxElo = Math.max(...results.map(r => r.eloRating), 1);
				const header = (key, label) => {
					const active = this.sortState.field === key;
					const className = active ? (this.sortState.direction === 1 ? 'sort-asc' : 'sort-desc') : '';
					const ariaSort = active ? (this.sortState.direction === 1 ? 'ascending' : 'descending') : 'none';
					return `<th class="${className}" data-sort="${key}" tabindex="0" role="columnheader" aria-sort="${ariaSort}">${label}</th>`;
				};

				const activeElement = document.activeElement;
				const savedSort = activeElement ? activeElement.dataset.sort : null;
				const savedId = activeElement ? activeElement.dataset.id : null;

				elements.resultsTable.innerHTML = `
					<h2>${this.string('resultsTitle')}</h2>
					<p class="info">${this.string('infoText')}</p>
					<div class="table-wrapper">
						<table>
							<thead>
								<tr>
									${header('eloRating', this.string('rank'))}
									${header('name', this.string('name'))}
									${header('displayWinRate', this.string('winRate'))}
									${this.mode === 'win' ? header('tieRate', this.string('tieRate')) : ''}
									${header('effectiveScore', this.string('effectiveScore'))}
									${header('eloRating', this.string('eloRating'))}
									${header('eloRating', this.string('relativeStrength'))}
									${header('eloDifference', this.string('eloDifference'))}
								</tr>
							</thead>
							<tbody>
								${calculatedResults.map((result, index) => {
									const isBaseline = result.id === baselineId;
									const isClosest = result.id === this.data.closestId && this.mode === 'elo';
									return `<tr class="${isBaseline ? 'highlight' : ''} ${isClosest ? 'avg-highlight' : ''}" style="cursor: pointer" data-id="${result.id}" tabindex="0" aria-selected="${isBaseline}">
										<td>${result.rank}</td>
										<td><strong>${escape(result.name)}</strong>${isClosest ? ' <span title="Closest to Average">~</span>' : ''}</td>
										<td>${this.format(result.displayWinRate, { maximumFractionDigits: 1 })}%</td>
										${this.mode === 'win' ? `<td>${this.format(result.tieRate || 0, { maximumFractionDigits: 1 })}%</td>` : ''}
										<td>${this.format(result.effectiveScore * 100, { maximumFractionDigits: 1 })}%</td>
										<td><strong>${Math.round(result.eloRating)}</strong></td>
										<td><div class="bar-container" title="${Math.round(result.eloRating)}" aria-hidden="true"><div class="bar" style="width:${Math.max(0, result.eloRating / maxElo * 100)}%"></div></div></td>
										<td>${result.eloDifference > 0 ? '+' : ''}${Math.round(result.eloDifference)}</td>
									</tr>`;
								}).join('')}
							</tbody>
						</table>
					</div>`;

				if (savedSort) elements.resultsTable.querySelector(`th[data-sort="${savedSort}"]`)?.focus();
				else if (savedId) elements.resultsTable.querySelector(`tr[data-id="${savedId}"]`)?.focus();
			}

			setBaseline(id) {
				if (this.data) {
					this.data.baselineId = isNaN(id) ? id : +id;
					this.renderResults();
				}
			}

			generateTableText(separator) {
				if (!this.data) return null;
				const { results, baselineId } = this.data;
				const baselineCompetitor = results.find(r => r.id === baselineId) || results[0];
				const headers = [
					this.string('rank'),
					this.string('name'),
					this.string('winRate'),
					...(this.mode === 'win' ? [this.string('tieRate')] : []),
					this.string('effectiveScore'),
					this.string('eloRating'),
					this.string('eloDifference')
				].join(separator);

				const escapeValue = value => {
					const stringValue = String(value);
					if (stringValue.includes(separator) || stringValue.includes('"') || stringValue.includes('\n')) return `"${stringValue.replace(/"/g, '""')}"`;
					return stringValue;
				};

				return headers + '\n' + results.map((result, index) => {
					const { eloDifference, effectiveScore } = this.calculateRowStats(result, baselineCompetitor);
					const displayWinRate = this.mode === 'win' ? (result.winRate || 0) : (effectiveScore * 100);
					return [
						index + 1,
						result.name,
						this.format(displayWinRate, { minimumFractionDigits: 1, maximumFractionDigits: 1 }),
						...(this.mode === 'win' ? [result.tieRate || 0] : []),
						this.format(effectiveScore * 100, { minimumFractionDigits: 1, maximumFractionDigits: 1 }),
						Math.round(result.eloRating),
						Math.round(eloDifference)
					].map(escapeValue).join(separator);
				}).join('\n');
			}

			export() {
				const csv = this.generateTableText(',');
				if (csv) Object.assign(document.createElement('a'), { href: URL.createObjectURL(new Blob([csv], { type: 'text/csv' })), download: `elo_ratings_${new Date().toISOString().slice(0, 19).replace(/[T:]/g, '-')}.csv` }).click();
			}

			copy() {
				const tsv = this.generateTableText('\t');
				if (tsv) {
					navigator.clipboard.writeText(tsv).then(() => {
						const originalText = elements.copy.textContent;
						elements.copy.textContent = this.string('copySuccess');
						setTimeout(() => elements.copy.textContent = originalText, 2000);
					});
				}
			}
		}
		new EloCalc();
	</script>
</body>
</html>
