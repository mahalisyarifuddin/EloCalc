<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width,initial-scale=1">
		<title>EloCalc</title>
		<style>
			:root {
				--primary: #005dac;
				--on-primary: #ffffff;
				--hover: #00539a;
				--background: #f9f9ff;
				--surface: #ffffff;
				--text: #181c21;
				--border: #c1c6d4;
				--muted: #f2f3fc;
				--success: #0b6b1d;
				--on-success: #ffffff;
				--danger: #ba1a1a;
				--on-danger: #ffffff;
				--highlight-bg: #d4e3ff;
			}
			@media (prefers-color-scheme: dark) {
				:root:not(.light) {
					--primary: #a5c8ff;
					--on-primary: #00315f;
					--hover: #72adff;
					--background: #101319;
					--surface: #0b0e14;
					--text: #e0e2ea;
					--border: #414752;
					--muted: #181c21;
					--success: #82db7e;
					--on-success: #00390a;
					--danger: #ffb4ab;
					--on-danger: #93000a;
					--highlight-bg: #001c3a;
				}
			}
			:root.dark {
				--primary: #a5c8ff;
				--on-primary: #00315f;
				--hover: #72adff;
				--background: #101319;
				--surface: #0b0e14;
				--text: #e0e2ea;
				--border: #414752;
				--muted: #181c21;
				--success: #82db7e;
				--on-success: #00390a;
				--danger: #ffb4ab;
				--on-danger: #93000a;
				--highlight-bg: #001c3a;
			}
			* {
				box-sizing: border-box;
				margin: 0;
				padding: 0;
				outline-offset: 2px;
			}
			*:focus-visible {
				outline: 2px solid var(--primary);
			}
			body {
				background: var(--background);
				color: var(--text);
				font-family: sans-serif;
				display: flex;
				justify-content: center;
				min-height: 100vh;
				padding: 1rem;
			}
			.container {
				background: var(--surface);
				border: 1px solid var(--border);
				border-radius: 8px;
				max-width: 960px;
				padding: 2rem;
				width: 100%;
				position: relative;
				margin: 2rem 0;
			}
			.hidden {
				display: none !important;
			}
			h1, h2, h3, label {
				margin: .5rem 0;
			}
			label {
				display: block;
				font-weight: 700;
			}
			input, select, button {
				background: var(--surface);
				border: 1px solid var(--border);
				border-radius: 4px;
				color: var(--text);
				font-size: 1rem;
				padding: .5rem;
				width: 100%;
			}
			button {
				cursor: pointer;
			}
			button:disabled {
				opacity: .6;
				cursor: not-allowed;
			}
			.primary {
				background: var(--primary);
				color: var(--on-primary);
				border: 0;
			}
			.primary:hover:not(:disabled) {
				background: var(--hover);
			}
			.secondary:hover:not(:disabled) {
				background: var(--muted);
			}
			.danger, .success {
				color: var(--on-danger);
				border: 0;
				background: var(--danger);
			}
			.success {
				background: var(--success);
				color: var(--on-success);
			}
			.danger:hover, .success:hover {
				filter: brightness(.9);
			}
			.selectors {
				position: absolute;
				right: 2rem;
				top: 1rem;
				display: flex;
				gap: 8px;
			}
			.selectors select {
				width: auto;
				font-size: .9rem;
			}
			.mode-elo .win-input,
			.mode-elo .tie-input,
			.mode-elo #headWin,
			.mode-elo #headTie,
			.mode-elo #allowTies,
			.mode-elo #allowTiesLabel,
			.mode-elo .options-row,
			.mode-elo .group {
				display: none !important;
			}
			.mode-win .elo-input,
			.mode-win #mainElo,
			.mode-win #headElo {
				display: none !important;
			}
			#mainElo {
				margin-top: 0.5rem;
			}
			.row {
				display: flex;
				gap: 1rem;
				margin-bottom: 1rem;
			}
			.group {
				flex: 1;
			}
			.competitor-row {
				display: flex;
				gap: .5rem;
				align-items: center;
				margin-bottom: .5rem;
			}
			.competitor-row input[type=text] {
				flex: 2;
			}
			.competitor-row input[type=number] {
				flex: 1;
			}
			.competitor-row button {
				width: auto;
				padding: .5rem 1rem;
			}
			table {
				border-collapse: collapse;
				margin-top: 1rem;
				width: 100%;
				font-size: .9rem;
			}
			th, td {
				border: 1px solid var(--border);
				padding: .5rem;
				text-align: left;
			}
			th {
				background: var(--primary);
				color: var(--on-primary);
			}
			.error {
				color: var(--danger);
				font-size: .9rem;
				margin: 1rem 0;
				display: block;
				font-weight: 500;
			}
			.info {
				font-size: .9rem;
				opacity: .8;
				line-height: 1.6;
				margin-bottom: 1rem;
			}
			.bar-container {
				background: var(--muted);
				border-radius: 4px;
				height: 8px;
				min-width: 80px;
				width: 100%;
				overflow: hidden;
			}
			.bar {
				background: var(--primary);
				height: 100%;
			}
			.actions {
				display: flex;
				gap: 1rem;
				margin-top: 1rem;
			}
			.table-wrapper {
				overflow-x: auto;
				-webkit-overflow-scrolling: touch;
				max-height: 70vh;
				overflow-y: auto;
				border-bottom: 1px solid var(--border);
			}
			.highlight {
				background-color: var(--highlight-bg);
			}
			input:out-of-range {
				border-color: var(--danger);
				background-color: var(--background);
			}
			.invalid {
				border-color: var(--danger);
				background-color: var(--background);
			}
			#listHeaders {
				position: -webkit-sticky;
				position: sticky;
				top: 0;
				z-index: 10;
				background: var(--surface);
				padding: .75rem 0;
				border-bottom: 1px solid var(--border);
				margin-bottom: .5rem;
			}
			th {
				position: -webkit-sticky;
				position: sticky;
				top: 0;
				z-index: 5;
			}
			@media(max-width: 768px) {
				.selectors {
					position: static;
					justify-content: end;
					margin-bottom: .5rem;
				}
				.row {
					flex-direction: column;
				}
			}

			/* Razor Refactor: Extracted styles */
			.options-row {
				align-items: center;
				margin-top: 1rem;
				gap: .5rem;
			}
			#allowTies {
				width: auto;
			}
			#allowTiesLabel {
				margin: 0;
			}
			#competitorsHeader {
				margin-top: 1.5rem;
			}
			#headName {
				flex: 2;
				font-size: .85rem;
				opacity: .8;
			}
			#headWin, #headTie {
				flex: 1;
				font-size: .85rem;
				opacity: .8;
			}
			.hidden-btn {
				visibility: hidden;
				cursor: default;
			}
			#list {
				margin-bottom: 1rem;
			}
			.controls-row {
				gap: .5rem;
			}
			#add, #clear, #import, #edit, #copy, #export {
				flex: 1;
			}
		</style>
	</head>
	<body>
		<div class="container">
			<div class="selectors">
				<select id="mode">
					<option value="win">Win Rate -> Elo</option>
					<option value="elo">Elo -> Win Rate</option>
				</select>
				<select id="language">
					<option value="en">English</option>
					<option value="id">Bahasa Indonesia</option>
				</select>
				<select id="theme">
					<option value="auto"></option>
					<option value="light"></option>
					<option value="dark"></option>
				</select>
			</div>
			<h1 id="title"></h1>
			<p id="subtitle" class="info"></p>
			<div id="input">
				<div class="group">
					<label id="mainLabel" for="mainName"></label>
					<input type="text" id="mainName" value="Player A">
					<input type="number" id="mainElo" placeholder="Elo" class="elo-input">
				</div>
				<div class="row options-row">
					<input type="checkbox" id="allowTies">
					<label for="allowTies" id="allowTiesLabel"></label>
				</div>
				<h3 id="competitorsHeader"></h3>
				<div id="listHeaders" class="competitor-row">
					<label id="headName"></label>
					<label id="headWin"></label>
					<label id="headTie"></label>
					<label id="headElo"></label>
					<button class="hidden-btn" aria-hidden="true">×</button>
				</div>
				<div id="list"></div>
				<div class="row controls-row">
					<button id="add" class="secondary"></button>
					<button id="clear" class="secondary"></button>
					<button id="import" class="secondary"></button>
				</div>
				<input type="file" id="file" accept=".csv,.tsv,.txt" class="hidden">
				<span id="error" class="error hidden" aria-live="polite"></span>
				<button id="calculate" class="primary"></button>
			</div>
			<div id="results" class="hidden">
				<div class="actions">
					<button id="edit" class="secondary"></button>
					<button id="copy" class="secondary"></button>
					<button id="export" class="success"></button>
				</div>
				<div id="resultsTable"></div>
			</div>
		</div>
		<script>
			const text = {
				en: {
					title: 'EloCalc',
					subtitle: 'Convert between Win Rates and Elo Ratings',
					autoTheme: 'Auto Theme',
					lightTheme: 'Light',
					darkTheme: 'Dark',
					mainLabel: 'Main Contender',
					allowTiesLabel: 'Include Tie Rates',
					competitorsHeader: 'Competitors',
					add: '+ Add Competitor',
					calculate: 'Calculate',
					edit: 'Edit Inputs',
					export: 'Export to CSV',
					copy: 'Copy Table',
					copySuccess: 'Copied!',
					import: 'Import CSV',
					clear: 'Clear All',
					clearConfirm: 'Are you sure you want to clear all competitors?',
					removeCompetitor: 'Remove Competitor',
					competitorPlaceholder: 'Competitor Name',
					winRatePlaceholder: 'Win % vs Main',
					tieRatePlaceholder: 'Tie % vs Main',
					eloPlaceholder: 'Elo Rating',
					alertCompetitors: 'Please add at least one competitor.',
					alertInvalidRate: 'Win rate and tie rate must be between 0-100, and their sum cannot exceed 100.',
					name: 'Name',
					winRate: 'Win Rate',
					tieRate: 'Tie Rate',
					effectiveScore: 'Expected Score',
					eloRating: 'Elo Rating',
					eloDifference: 'Elo Diff',
					relativeStrength: 'Relative Strength',
					resultsTitle: 'Results',
					infoText: 'Click any row to set it as the baseline. The 400-point rule: A 400-point difference equals ~91% expected win rate.',
					alertImport: 'Error importing file. Please ensure it is a valid CSV/TSV.',
					languageLabel: 'Language',
					themeLabel: 'Theme',
					modeLabel: 'Mode',
					modeWin: 'Win Rate -> Elo',
					modeElo: 'Elo -> Win Rate',
					rank: '#'
				},
				id: {
					title: 'EloCalc',
					subtitle: 'Konversi antara Tingkat Kemenangan dan Peringkat Elo',
					autoTheme: 'Tema Otomatis',
					lightTheme: 'Terang',
					darkTheme: 'Gelap',
					mainLabel: 'Pesaing Utama',
					allowTiesLabel: 'Sertakan Tingkat Seri',
					competitorsHeader: 'Kompetitor',
					add: '+ Tambah Kompetitor',
					calculate: 'Hitung',
					edit: 'Ubah Input',
					export: 'Ekspor ke CSV',
					copy: 'Salin Tabel',
					copySuccess: 'Tersalin!',
					import: 'Impor CSV',
					clear: 'Hapus Semua',
					clearConfirm: 'Apakah Anda yakin ingin menghapus semua kompetitor?',
					removeCompetitor: 'Hapus Kompetitor',
					competitorPlaceholder: 'Nama Kompetitor',
					winRatePlaceholder: 'Menang % vs Utama',
					tieRatePlaceholder: 'Seri % vs Utama',
					eloPlaceholder: 'Peringkat Elo',
					alertCompetitors: 'Harap tambahkan setidaknya satu kompetitor.',
					alertInvalidRate: 'Tingkat menang dan seri harus antara 0-100, dan jumlahnya tidak boleh melebihi 100.',
					name: 'Nama',
					winRate: 'Menang %',
					tieRate: 'Seri %',
					effectiveScore: 'Skor Harapan',
					eloRating: 'Peringkat Elo',
					eloDifference: 'Selisih Elo',
					relativeStrength: 'Kekuatan Relatif',
					resultsTitle: 'Hasil',
					infoText: 'Klik baris mana saja untuk menjadikannya acuan. Aturan 400 poin: Selisih 400 poin setara dengan ~91% tingkat menang yang diharapkan.',
					alertImport: 'Gagal mengimpor file. Pastikan format CSV/TSV valid.',
					languageLabel: 'Bahasa',
					themeLabel: 'Tema',
					modeLabel: 'Mode',
					modeWin: 'Tingkat Menang -> Elo',
					modeElo: 'Elo -> Tingkat Menang',
					rank: '#'
				}
			};
			const elements = new Proxy({}, { get: (_, id) => document.getElementById(id) });
			const escape = string => string.replace(/[&<>"']/g, char => '&#' + char.charCodeAt(0) + ';');

			const parseCSV = text => {
				const firstLine = text.split('\n')[0];
				let commas = 0, tabs = 0, inside = false;
				for (const char of firstLine) {
					if (char === '"') inside = !inside;
					else if (!inside) {
						if (char === ',') commas++;
						else if (char === '\t') tabs++;
					}
				}
				const separator = tabs >= commas && tabs > 0 ? '\t' : ',';
				const rows = [];
				let currentRow = [];
				let currentCell = '';
				let insideQuote = false;

				for (let i = 0; i < text.length; i++) {
					const char = text[i];
					const nextChar = text[i + 1];

					if (char === '"') insideQuote = !insideQuote;

					if (char === separator && !insideQuote) {
						currentRow.push(currentCell);
						currentCell = '';
					} else if ((char === '\n' || char === '\r') && !insideQuote) {
						if (char === '\r' && nextChar === '\n') i++;
						currentRow.push(currentCell);
						if (currentRow.length > 1 || currentRow[0].trim()) rows.push(currentRow);
						currentRow = [];
						currentCell = '';
					} else {
						currentCell += char;
					}
				}
				if (currentCell || currentRow.length) {
					currentRow.push(currentCell);
					if (currentRow.length > 1 || currentRow[0].trim()) rows.push(currentRow);
				}
				return rows.map(row => row.map(cell => cell.trim().replace(/^"|"$/g, '').replace(/""/g, '"')));
			};

			class EloCalc {
				constructor() {
					this.competitors = Object.entries({
						'Player B': [65, 10, 1000],
						'Player C': [45, 15, 1200],
						'Player D': [30, 20, 800]
					}).map(([name, [winRate, tieRate, elo]], i) => ({
						id: i + 1,
						name,
						winRate,
						tieRate,
						elo
					}));
					this.nextIndex = 4;
					this.data = null;
					this.allowTies = true;
					this.mode = 'win';
					this.setup();
					this.theme('auto');
					this.lang(navigator.language?.startsWith('id') ? 'id' : 'en');
					this.setMode('win');
					window.setBaseline = (id) => this.setBaseline(id);
				}
				setup() {
					const handlers = {
						add: () => this.add(),
						clear: () => this.clear(),
						calculate: () => this.calculate(),
						edit: () => this.display('input'),
						copy: () => this.copy(),
						export: () => this.export(),
						import: () => elements.file.click()
					};
					Object.entries(handlers).forEach(([id, handler]) => elements[id].onclick = handler);
					elements.file.onchange = event => this.load(event.target.files[0]);
					elements.input.oninput = event => {
						this.error();
						if (event.target.matches('.win-input, .tie-input')) {
							this.validateRow(event.target.closest('.competitor-row'));
						}
					};
					elements.language.onchange = event => this.lang(event.target.value);
					elements.theme.onchange = event => this.theme(event.target.value);
					elements.mode.onchange = event => this.setMode(event.target.value);
					elements.allowTies.onchange = event => {
						this.allowTies = event.target.checked;
						elements.headTie.classList.toggle('hidden', !this.allowTies);
						document.querySelectorAll('.tie-input').forEach(el => el.classList.toggle('hidden', !this.allowTies));
						document.querySelectorAll('.competitor-row').forEach(row => this.validateRow(row));
					};
					elements.allowTies.checked = this.allowTies;
					document.onkeydown = event => this.key(event);
					elements.list.onclick = event => {
						const row = event.target.closest('.competitor-row');
						if (event.target.matches('.danger') && row) {
							this.remove(+row.dataset.id);
						}
					};
					elements.list.onchange = event => {
						const row = event.target.closest('.competitor-row');
						const comp = row && this.competitors.find(c => c.id === +row.dataset.id);
						if (comp) this.updateCompetitor(comp, event.target);
					};
				}
				key(event) {
					if (event.key !== 'Enter') return;

					if (event.ctrlKey || event.metaKey) {
						this.calculate();
						return;
					}

					if (event.target.matches('input') && event.target.closest('.competitor-row')) {
						event.preventDefault();
						const row = event.target.closest('.competitor-row');
						const comp = this.competitors.find(c => c.id === +row.dataset.id);
						if (comp) this.updateCompetitor(comp, event.target);
						this.focusNext(event.target, row);
					} else if (event.target.matches('#mainName, #allowTies')) {
						event.preventDefault();
						const firstInput = elements.list.firstElementChild?.querySelector('input');
						if (firstInput) {
							firstInput.focus();
						} else {
							elements.add.focus();
						}
					}
				}

				updateCompetitor(comp, target) {
					const val = target.value;
					if (target.classList.contains('name-input')) {
						comp.name = val;
					} else if (target.classList.contains('win-input')) {
						this.updateRate(comp, 'winRate', val, target);
					} else if (target.classList.contains('tie-input')) {
						this.updateRate(comp, 'tieRate', val, target);
					} else if (target.classList.contains('elo-input')) {
						this.updateRate(comp, 'elo', val, target);
					}
				}

				updateRate(comp, prop, value, target) {
					const num = value === '' ? '' : (parseFloat(value) || 0);
					comp[prop] = num;
				}

				focusNext(target, row) {
					if (target.type === 'text') {
						target.nextElementSibling?.focus();
					} else if (target.classList.contains('win-input') && this.allowTies) {
						target.nextElementSibling?.focus();
					} else if (row.nextElementSibling) {
						row.nextElementSibling.querySelector('input')?.focus();
					} else {
						this.add();
					}
				}
				string(key) {
					return text[this.language]?.[key] ?? key;
				}
				format(value, options = {}) {
					return value.toLocaleString(this.language === 'id' ? 'id-ID' : 'en-US', options);
				}
				theme(themeName) {
					document.documentElement.className = themeName === 'auto' ? '' : themeName;
					elements.theme.value = themeName;
				}
				lang(language) {
					this.language = elements.language.value = document.documentElement.lang = language;
					Object.keys(text.en).forEach(key => {
						if (elements[key]) elements[key].textContent = this.string(key);
					});
					this.updateLabels();
					[...elements.theme.options].forEach(option => option.textContent = this.string(option.value + 'Theme'));
					[['language', 'languageLabel'], ['theme', 'themeLabel'], ['mode', 'modeLabel']].forEach(([id, key]) => elements[id].setAttribute('aria-label', this.string(key)));
					this.renderCompetitors();
					if (!elements.results.classList.contains('hidden') && this.data) {
						this.renderResults();
					}
				}
				setMode(mode) {
					this.mode = mode;
					elements.input.className = `mode-${mode}`;
					elements.mode.value = mode;
					this.error();
					this.renderCompetitors();
				}
				updateLabels() {
					elements.headName.textContent = this.string('name');
					elements.headWin.textContent = this.string('winRatePlaceholder');
					elements.headTie.textContent = this.string('tieRatePlaceholder');
					elements.headElo.textContent = this.string('eloPlaceholder');
					[...elements.mode.options].forEach(option => option.textContent = this.string(option.value === 'win' ? 'modeWin' : 'modeElo'));
				}
				display(section) {
					['input', 'results'].forEach(id => elements[id].classList.toggle('hidden', id !== section));
					if (section === 'results') {
						elements.results.setAttribute('tabindex', '-1');
						elements.results.focus();
					} else {
						elements.mainName.focus();
					}
				}
				error(message) {
					elements.error.textContent = message || '';
					elements.error.classList.toggle('hidden', !message);
				}
				add() {
					this.error();
					this.competitors.push({ id: this.nextIndex++, name: '', winRate: '', tieRate: '', elo: '' });
					this.renderCompetitors();
					elements.list.lastElementChild?.querySelector('input')?.focus();
				}
				clear() {
					if (confirm(this.string('clearConfirm'))) {
						this.competitors = [];
						this.renderCompetitors();
						this.add();
						this.error();
					}
				}
				remove(id) {
					this.error();
					const index = this.competitors.findIndex(c => c.id === id);
					this.competitors = this.competitors.filter(c => c.id !== id);
					this.renderCompetitors();
					const target = Math.min(index, this.competitors.length - 1);
					if (target >= 0) {
						elements.list.children[target]?.querySelector('.danger')?.focus();
					} else {
						elements.add.focus();
					}
				}
				renderCompetitors() {
					elements.headTie.classList.toggle('hidden', !this.allowTies);
					elements.list.innerHTML = this.competitors.map((comp, i) => {
						const invalid = this.isInvalid(comp) ? 'invalid' : '';
						return `<div class="competitor-row" data-id="${comp.id}">
							<input type="text" class="name-input" value="${escape(comp.name)}" placeholder="${this.string('competitorPlaceholder')}" aria-label="${this.string('competitorPlaceholder')} ${i + 1}">
							<input type="number" class="win-input ${invalid}" value="${comp.winRate}" placeholder="${this.string('winRatePlaceholder')}" min="0" max="100" step="0.1" aria-label="${this.string('winRatePlaceholder')} ${i + 1}">
							<input type="number" class="tie-input ${this.allowTies ? '' : 'hidden'} ${invalid}" value="${comp.tieRate}" placeholder="${this.string('tieRatePlaceholder')}" min="0" max="100" step="0.1" aria-label="${this.string('tieRatePlaceholder')} ${i + 1}">
							<input type="number" class="elo-input" value="${comp.elo}" placeholder="${this.string('eloPlaceholder')}" aria-label="${this.string('eloPlaceholder')} ${i + 1}">
							<button class="danger" aria-label="${this.string('removeCompetitor')} ${i + 1}">×</button>
						</div>`;
					}).join('');
				}
				load(file) {
					const reader = new FileReader();
					reader.onload = event => {
						try {
							const rows = parseCSV(event.target.result);
							if (!rows.length) throw new Error();

							const header = rows[0];
							const find = regex => header.findIndex(cell => regex.test(cell));
							let nameIndex = find(/name|nama/i);
							let winIndex = find(/win|menang/i);
							let tieIndex = find(/tie|seri/i);

							if (nameIndex < 0 || winIndex < 0) {
								nameIndex = 0;
								winIndex = 1;
								const isAllNumbers = header.every(cell => /^\d+$/.test(cell.replace(/[.,]/g, '').trim()));
								if (isAllNumbers) {
									winIndex = header.findIndex(cell => /^\d+$/.test(cell.replace(/[.,]/g, '').trim()));
									nameIndex = 1 - winIndex;
								}
							}

							if (nameIndex < 0 || winIndex < 0) throw new Error();

							// Detect if the first row is actually data (headless CSV)
							// If keywords were found, it's definitely a header.
							// If not, checks if the determined 'win' column contains a number.
							const isWinNum = !isNaN(parseFloat((header[winIndex] || '').replace(',', '.')));
							const hasHeader = (find(/name|nama/i) >= 0 || find(/win|menang/i) >= 0) || !isWinNum;

							const competitors = (hasHeader ? rows.slice(1) : rows).map(cells => {
								if (!cells[nameIndex]) return null;
								const winRate = +((cells[winIndex] || '').replace(/,/g, '.').replace(/[^\d.]/g, '')) || 0;
								const tieRate = tieIndex >= 0 ? (+((cells[tieIndex] || '').replace(/,/g, '.').replace(/[^\d.]/g, '')) || 0) : 0;
								return {
									id: this.nextIndex++,
									name: cells[nameIndex],
									winRate,
									tieRate
								};
							}).filter(Boolean);

							if (!competitors.length) throw new Error();

							this.competitors = competitors;
							if (tieIndex >= 0) {
								this.allowTies = true;
								elements.allowTies.checked = true;
							}

							this.error();
							this.renderCompetitors();
							elements.file.value = '';
						} catch {
							this.error(this.string('alertImport'));
						}
					};
					if (file) reader.readAsText(file);
				}
				calculate() {
					this.error();
					const mainName = elements.mainName.value.trim() || 'Main';

					this.competitors = this.competitors.filter(c =>
						c.name.trim() ||
						(this.mode === 'win' && (c.winRate > 0 || c.tieRate > 0)) ||
						(this.mode === 'elo' && c.elo !== '')
					);
					this.renderCompetitors();

					let error = !this.competitors.length ? 'alertCompetitors' : null;
					if (!error && this.mode === 'win' && this.hasInvalidRates()) {
						error = 'alertInvalidRate';
					}

					if (error) {
						this.error(this.string(error));
					} else {
						this.performCalculation(mainName);
					}
				}

				hasInvalidRates() {
					return this.competitors.some(comp => {
						const tieRate = this.allowTies ? +comp.tieRate : 0;
						const winRate = +comp.winRate;
						return winRate < 0 || winRate > 100 || tieRate < 0 || tieRate > 100 || winRate + tieRate > 100;
					});
				}

				performCalculation(mainName) {
					let allRaw = [];
					let baselineId = 'main';

					if (this.mode === 'win') {
						const rawResults = this.competitors.map(comp => this.calculateRow(comp));
						allRaw = [{ name: mainName, rawElo: 0, isMain: true, id: 'main', winRate: 50, tieRate: 0 }, ...rawResults];
						const avgElo = allRaw.reduce((sum, r) => sum + r.rawElo, 0) / allRaw.length;
						const adjustment = 1000 - avgElo;
						allRaw.forEach(r => r.eloRating = r.rawElo + adjustment);
					} else {
						allRaw = this.competitors.map(c => ({
							name: c.name.trim() || `Competitor ${c.id}`,
							eloRating: parseFloat(c.elo) || 0,
							id: c.id
						}));
						if (allRaw.length > 0) {
							// Sort first to find the top Elo as default baseline? Or just use the first?
							// Let's use the first one in the list as default if not sorted.
							// Actually, let's just pick the one with the highest Elo as default baseline for display?
							// Or just the first one. Let's stick to the first one for stability.
							baselineId = allRaw[0].id;
						}
					}

					this.data = {
						results: allRaw.sort((a, b) => b.eloRating - a.eloRating),
						allowTies: this.allowTies,
						baselineId: this.data?.baselineId && allRaw.find(r => r.id === this.data.baselineId) ? this.data.baselineId : baselineId
					};

					this.renderResults();
					this.display('results');
				}

				calculateRow(comp) {
					const tieRate = this.allowTies ? +comp.tieRate : 0;
					const effectiveScore = (+comp.winRate + tieRate * 0.5) / 100;

					const eloDiff = effectiveScore >= 1 ? 2000 :
					                effectiveScore <= 0 ? -2000 :
					                -400 * Math.log10(1 / effectiveScore - 1);

					return {
						name: comp.name.trim() || `Competitor ${comp.id}`,
						rawElo: eloDiff,
						id: comp.id,
						winRate: +comp.winRate,
						tieRate
					};
				}

				isInvalid(comp) {
					if (this.mode === 'elo') return false;
					const tieRate = this.allowTies ? +comp.tieRate : 0;
					return (+comp.winRate + tieRate) > 100;
				}

				validateRow(row) {
					if (!row || this.mode === 'elo') {
						if (row) row.querySelectorAll('input').forEach(i => i.classList.remove('invalid'));
						return;
					}
					const winInput = row.querySelector('.win-input');
					const tieInput = row.querySelector('.tie-input');
					if (!winInput || !tieInput) return;

					const comp = {
						winRate: winInput.value,
						tieRate: tieInput.value
					};
					const invalid = this.isInvalid(comp);

					winInput.classList.toggle('invalid', invalid);
					tieInput.classList.toggle('invalid', invalid && this.allowTies);
				}

				renderResults() {
					if (this.data) {
						const { results, baselineId } = this.data;
						const baselineComp = results.find(r => r.id === baselineId) || results[0];

						const calculatedResults = results.map(r => {
							const eloDiff = r.eloRating - baselineComp.eloRating;
							const effectiveScore = 1 / (1 + Math.pow(10, -eloDiff / 400));

							return {
								...r,
								eloDiff,
								effectiveScore,
								displayWinRate: this.mode === 'win' ? r.winRate : effectiveScore * 100
							};
						});

						const maxElo = Math.max(...results.map(r => r.eloRating), 1);

						elements.resultsTable.innerHTML = `
							<h2>${this.string('resultsTitle')}</h2>
							<p class="info">${this.string('infoText')}</p>
							<div class="table-wrapper">
								<table>
									<thead>
										<tr>
											<th>${this.string('rank')}</th>
											<th>${this.string('name')}</th>
											<th>${this.string('winRate')}</th>
											${this.mode === 'win' ? `<th>${this.string('tieRate')}</th>` : ''}
											<th>${this.string('effectiveScore')}</th>
											<th>${this.string('eloRating')}</th>
											<th>${this.string('relativeStrength')}</th>
											<th>${this.string('eloDifference')}</th>
										</tr>
									</thead>
									<tbody>
										${calculatedResults.map((result, i) => {
											const isBaseline = result.id === baselineId;
											return `<tr class="${isBaseline ? 'highlight' : ''}" style="cursor: pointer" onclick="window.setBaseline('${result.id}')">
												<td>${i + 1}</td>
												<td><strong>${escape(result.name)}</strong></td>
												<td>${this.format(result.displayWinRate, { maximumFractionDigits: 1 })}%</td>
												${this.mode === 'win' ? `<td>${this.format(result.tieRate || 0, { maximumFractionDigits: 1 })}%</td>` : ''}
												<td>${this.format(result.effectiveScore * 100, { maximumFractionDigits: 1 })}%</td>
												<td><strong>${Math.round(result.eloRating)}</strong></td>
												<td><div class="bar-container" title="${Math.round(result.eloRating)}" aria-hidden="true"><div class="bar" style="width:${Math.max(0, result.eloRating / maxElo * 100)}%"></div></div></td>
												<td>${result.eloDiff > 0 ? '+' : ''}${Math.round(result.eloDiff)}</td>
											</tr>`;
										}).join('')}
									</tbody>
								</table>
							</div>`;
					}
				}

				setBaseline(id) {
					if (this.data) {
						this.data.baselineId = isNaN(id) ? id : +id;
						this.renderResults();
					}
				}

				export() {
					if (this.data) {
						const { results, baselineId } = this.data;
						const baselineComp = results.find(r => r.id === baselineId) || results[0];
						const headers = [
							this.string('rank'),
							this.string('name'),
							this.string('winRate'),
							...(this.mode === 'win' ? [this.string('tieRate')] : []),
							this.string('effectiveScore'),
							this.string('eloRating'),
							this.string('eloDifference')
						].join(',');

						const csv = headers + '\n' + results.map((result, i) => {
							const eloDiff = result.eloRating - baselineComp.eloRating;
							const effectiveScore = 1 / (1 + Math.pow(10, -eloDiff / 400));
							const displayWinRate = this.mode === 'win' ? (result.winRate || 0) : (effectiveScore * 100);
							return [
								i + 1,
								`"${result.name.replace(/"/g, '""')}"`,
								this.format(displayWinRate, { minimumFractionDigits: 1, maximumFractionDigits: 1 }),
								...(this.mode === 'win' ? [result.tieRate || 0] : []),
								this.format(effectiveScore * 100, { minimumFractionDigits: 1, maximumFractionDigits: 1 }),
								Math.round(result.eloRating),
								Math.round(eloDiff)
							].join(',');
						}).join('\n');

						Object.assign(document.createElement('a'), { href: URL.createObjectURL(new Blob([csv], { type: 'text/csv' })), download: `elo_ratings_${new Date().toISOString().slice(0, 19).replace(/[T:]/g, '-')}.csv` }).click();
					}
				}
				copy() {
					if (this.data) {
						const { results, baselineId } = this.data;
						const baselineComp = results.find(r => r.id === baselineId) || results[0];
						const headers = [
							this.string('rank'),
							this.string('name'),
							this.string('winRate'),
							...(this.mode === 'win' ? [this.string('tieRate')] : []),
							this.string('effectiveScore'),
							this.string('eloRating'),
							this.string('eloDifference')
						].join('\t');

						const tsv = headers + '\n' + results.map((result, i) => {
							const eloDiff = result.eloRating - baselineComp.eloRating;
							const effectiveScore = 1 / (1 + Math.pow(10, -eloDiff / 400));
							const displayWinRate = this.mode === 'win' ? (result.winRate || 0) : (effectiveScore * 100);
							return [
								i + 1,
								`"${result.name.replace(/"/g, '""')}"`,
								this.format(displayWinRate, { minimumFractionDigits: 1, maximumFractionDigits: 1 }),
								...(this.mode === 'win' ? [result.tieRate || 0] : []),
								this.format(effectiveScore * 100, { minimumFractionDigits: 1, maximumFractionDigits: 1 }),
								Math.round(result.eloRating),
								Math.round(eloDiff)
							].join('\t');
						}).join('\n');

						navigator.clipboard.writeText(tsv).then(() => {
							const originalText = elements.copy.textContent;
							elements.copy.textContent = this.string('copySuccess');
							setTimeout(() => elements.copy.textContent = originalText, 2000);
						});
					}
				}
			}
			new EloCalc();
		</script>
	</body>
</html>