<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width,initial-scale=1">
		<title>EloCalc</title>
		<style>
			:root {
				--primary: #005dac;
				--on-primary: #ffffff;
				--hover: #00539a;
				--background: #f9f9ff;
				--surface: #ffffff;
				--text: #181c21;
				--border: #c1c6d4;
				--muted: #f2f3fc;
				--success: #0b6b1d;
				--on-success: #ffffff;
				--danger: #ba1a1a;
				--on-danger: #ffffff;
				--highlight-bg: #d4e3ff;
			}
			@media (prefers-color-scheme: dark) {
				:root:not(.light) {
					--primary: #a5c8ff;
					--on-primary: #00315f;
					--hover: #72adff;
					--background: #101319;
					--surface: #0b0e14;
					--text: #e0e2ea;
					--border: #414752;
					--muted: #181c21;
					--success: #82db7e;
					--on-success: #00390a;
					--danger: #ffb4ab;
					--on-danger: #93000a;
					--highlight-bg: #001c3a;
				}
			}
			:root.dark {
				--primary: #a5c8ff;
				--on-primary: #00315f;
				--hover: #72adff;
				--background: #101319;
				--surface: #0b0e14;
				--text: #e0e2ea;
				--border: #414752;
				--muted: #181c21;
				--success: #82db7e;
				--on-success: #00390a;
				--danger: #ffb4ab;
				--on-danger: #93000a;
				--highlight-bg: #001c3a;
			}
			* {
				box-sizing: border-box;
				margin: 0;
				padding: 0;
				outline-offset: 2px;
			}
			*:focus-visible {
				outline: 2px solid var(--primary);
			}
			body {
				background: var(--background);
				color: var(--text);
				font-family: sans-serif;
				display: flex;
				justify-content: center;
				min-height: 100vh;
				padding: 1rem;
			}
			.container {
				background: var(--surface);
				border: 1px solid var(--border);
				border-radius: 8px;
				max-width: 960px;
				padding: 2rem;
				width: 100%;
				position: relative;
				margin: 2rem 0;
			}
			.hidden {
				display: none !important;
			}
			h1, h2, h3, label {
				margin: .5rem 0;
			}
			label {
				display: block;
				font-weight: 700;
			}
			input, select, button {
				background: var(--surface);
				border: 1px solid var(--border);
				border-radius: 4px;
				color: var(--text);
				font-size: 1rem;
				padding: .5rem;
				width: 100%;
			}
			button {
				cursor: pointer;
			}
			button:disabled {
				opacity: .6;
				cursor: not-allowed;
			}
			.primary {
				background: var(--primary);
				color: var(--on-primary);
				border: 0;
			}
			.primary:hover:not(:disabled) {
				background: var(--hover);
			}
			.secondary:hover:not(:disabled) {
				background: var(--muted);
			}
			.danger, .success {
				color: var(--on-danger);
				border: 0;
				background: var(--danger);
			}
			.success {
				background: var(--success);
				color: var(--on-success);
			}
			.danger:hover, .success:hover {
				filter: brightness(.9);
			}
			.selectors {
				position: absolute;
				right: 2rem;
				top: 1rem;
				display: flex;
				gap: 8px;
			}
			.selectors select {
				width: auto;
				font-size: .9rem;
			}
			.row {
				display: flex;
				gap: 1rem;
				margin-bottom: 1rem;
			}
			.group {
				flex: 1;
			}
			.competitor-row {
				display: flex;
				gap: .5rem;
				align-items: center;
				margin-bottom: .5rem;
			}
			.competitor-row input[type=text] {
				flex: 2;
			}
			.competitor-row input[type=number] {
				flex: 1;
			}
			.competitor-row button {
				width: auto;
				padding: .5rem 1rem;
			}
			table {
				border-collapse: collapse;
				margin-top: 1rem;
				width: 100%;
				font-size: .9rem;
			}
			th, td {
				border: 1px solid var(--border);
				padding: .5rem;
				text-align: left;
			}
			th {
				background: var(--primary);
				color: var(--on-primary);
			}
			.error {
				color: var(--danger);
				font-size: .9rem;
				margin: 1rem 0;
				display: block;
				font-weight: 500;
			}
			.info {
				font-size: .9rem;
				opacity: .8;
				line-height: 1.6;
				margin-bottom: 1rem;
			}
			.bar-container {
				background: var(--muted);
				border-radius: 4px;
				height: 8px;
				min-width: 80px;
				width: 100%;
				overflow: hidden;
			}
			.bar {
				background: var(--primary);
				height: 100%;
			}
			.actions {
				display: flex;
				gap: 1rem;
				margin-top: 1rem;
			}
			@media(max-width: 768px) {
				.selectors {
					position: static;
					justify-content: end;
					margin-bottom: .5rem;
				}
				.row {
					flex-direction: column;
				}
			}
		</style>
	</head>
	<body>
		<div class="container">
			<div class="selectors">
				<select id="language">
					<option value="en">English</option>
					<option value="id">Bahasa Indonesia</option>
				</select>
				<select id="theme">
					<option value="auto"></option>
					<option value="light"></option>
					<option value="dark"></option>
				</select>
			</div>
			<h1 id="title"></h1>
			<p id="subtitle" class="info"></p>
			<div id="input">
				<div class="group">
					<label id="mainLabel" for="mainName"></label>
					<input type="text" id="mainName" value="Player A">
				</div>
				<div class="row" style="align-items:center;margin-top:1rem;gap:.5rem">
					<input type="checkbox" id="allowTies" style="width:auto">
					<label for="allowTies" id="allowTiesLabel" style="margin:0"></label>
				</div>
				<h3 id="competitorsHeader" style="margin-top:1.5rem"></h3>
				<div id="listHeaders" class="competitor-row" style="margin-bottom:.25rem">
					<label id="headName" style="flex:2;font-size:.85rem;opacity:.8"></label>
					<label id="headWin" style="flex:1;font-size:.85rem;opacity:.8"></label>
					<label id="headTie" style="flex:1;font-size:.85rem;opacity:.8"></label>
					<button style="visibility:hidden;cursor:default" aria-hidden="true">×</button>
				</div>
				<div id="list" style="margin-bottom:1rem"></div>
				<div class="row" style="gap:.5rem">
					<button id="add" class="secondary" style="flex:1"></button>
					<button id="clear" class="secondary" style="flex:1"></button>
					<button id="import" class="secondary" style="flex:1"></button>
				</div>
				<input type="file" id="file" accept=".csv,.tsv,.txt" class="hidden">
				<span id="error" class="error hidden" aria-live="polite"></span>
				<button id="calculate" class="primary"></button>
			</div>
			<div id="results" class="hidden">
				<div class="actions">
					<button id="edit" class="secondary" style="flex:1"></button>
					<button id="export" class="success" style="flex:1"></button>
				</div>
				<div id="resultsTable"></div>
			</div>
		</div>
		<script>
			const text = {
				en: {
					title: 'EloCalc',
					subtitle: 'Convert win rates to Elo ratings (normalized to average 1000)',
					autoTheme: 'Auto Theme',
					lightTheme: 'Light',
					darkTheme: 'Dark',
					mainLabel: 'Main Contender Name',
					allowTiesLabel: 'Include Tie Rates',
					competitorsHeader: 'Competitors',
					add: '+ Add Competitor',
					calculate: 'Calculate Ratings',
					edit: 'Edit Inputs',
					export: 'Export to CSV',
					import: 'Import CSV',
					clear: 'Clear All',
					clearConfirm: 'Are you sure you want to clear all competitors?',
					removeCompetitor: 'Remove Competitor',
					competitorPlaceholder: 'Competitor Name',
					winRatePlaceholder: 'Win % vs Main',
					tieRatePlaceholder: 'Tie % vs Main',
					alertCompetitors: 'Please add at least one competitor.',
					alertInvalidRate: 'Win rate and tie rate must be between 0-100, and their sum cannot exceed 100.',
					name: 'Name',
					winRate: 'Win Rate vs Main',
					tieRate: 'Tie Rate vs Main',
					effectiveScore: 'Effective Score',
					eloRating: 'Elo Rating',
					eloDifference: 'Elo Diff',
					relativeStrength: 'Relative Strength',
					resultsTitle: 'Calculated Elo Ratings',
					infoText: 'Inputs are the competitor\'s win/tie rates against the main contender. The 400-point rule: A 400-point difference equals ~91% expected win rate. Ties count as 0.5 wins. All ratings are normalized to average 1000.',
					alertImport: 'Error importing file. Please ensure it is a valid CSV/TSV with "Name", "Win", and optional "Tie" columns.',
					languageLabel: 'Language',
					themeLabel: 'Theme'
				},
				id: {
					title: 'EloCalc',
					subtitle: 'Konversi tingkat kemenangan ke peringkat Elo (dinormalisasi ke rata-rata 1000)',
					autoTheme: 'Tema Otomatis',
					lightTheme: 'Terang',
					darkTheme: 'Gelap',
					mainLabel: 'Nama Pesaing Utama',
					allowTiesLabel: 'Sertakan Tingkat Seri',
					competitorsHeader: 'Kompetitor',
					add: '+ Tambah Kompetitor',
					calculate: 'Hitung Peringkat',
					edit: 'Ubah Input',
					export: 'Ekspor ke CSV',
					import: 'Impor CSV',
					clear: 'Hapus Semua',
					clearConfirm: 'Apakah Anda yakin ingin menghapus semua kompetitor?',
					removeCompetitor: 'Hapus Kompetitor',
					competitorPlaceholder: 'Nama Kompetitor',
					winRatePlaceholder: 'Menang % vs Utama',
					tieRatePlaceholder: 'Seri % vs Utama',
					alertCompetitors: 'Harap tambahkan setidaknya satu kompetitor.',
					alertInvalidRate: 'Tingkat menang dan seri harus antara 0-100, dan jumlahnya tidak boleh melebihi 100.',
					name: 'Nama',
					winRate: 'Menang % vs Utama',
					tieRate: 'Seri % vs Utama',
					effectiveScore: 'Skor Efektif',
					eloRating: 'Peringkat Elo',
					eloDifference: 'Selisih Elo',
					relativeStrength: 'Kekuatan Relatif',
					resultsTitle: 'Peringkat Elo Terhitung',
					infoText: 'Input adalah tingkat menang/seri kompetitor melawan pesaing utama. Aturan 400 poin: Selisih 400 poin setara dengan ~91% tingkat menang yang diharapkan. Seri dihitung sebagai 0.5 kemenangan. Semua peringkat dinormalisasi ke rata-rata 1000.',
					alertImport: 'Gagal mengimpor file. Pastikan format CSV/TSV valid dengan kolom "Nama", "Menang", dan opsional "Seri".',
					languageLabel: 'Bahasa',
					themeLabel: 'Tema'
				}
			};
			const elements = new Proxy({}, { get: (_, id) => document.getElementById(id) });
			const escape = string => string.replace(/[&<>"']/g, char => '&#' + char.charCodeAt(0) + ';');

			const parseCSV = text => {
				const firstLine = text.split('\n')[0];
				let commas = 0, tabs = 0, inside = false;
				for (const char of firstLine) {
					if (char === '"') inside = !inside;
					else if (!inside) {
						if (char === ',') commas++;
						else if (char === '\t') tabs++;
					}
				}
				const separator = tabs >= commas && tabs > 0 ? '\t' : ',';
				const rows = [];
				let currentRow = [];
				let currentCell = '';
				let insideQuote = false;

				for (let i = 0; i < text.length; i++) {
					const char = text[i];
					const nextChar = text[i + 1];

					if (char === '"') insideQuote = !insideQuote;

					if (char === separator && !insideQuote) {
						currentRow.push(currentCell);
						currentCell = '';
					} else if ((char === '\n' || char === '\r') && !insideQuote) {
						if (char === '\r' && nextChar === '\n') i++;
						currentRow.push(currentCell);
						if (currentRow.length > 1 || currentRow[0].trim()) rows.push(currentRow);
						currentRow = [];
						currentCell = '';
					} else {
						currentCell += char;
					}
				}
				if (currentCell || currentRow.length) {
					currentRow.push(currentCell);
					if (currentRow.length > 1 || currentRow[0].trim()) rows.push(currentRow);
				}
				return rows.map(row => row.map(cell => cell.trim().replace(/^"|"$/g, '').replace(/""/g, '"')));
			};

			class EloCalc {
				constructor() {
					this.competitors = Object.entries({
						'Player B': [65, 10],
						'Player C': [45, 15],
						'Player D': [30, 20]
					}).map(([name, [winRate, tieRate]], i) => ({
						id: i + 1,
						name,
						winRate,
						tieRate
					}));
					this.nextIndex = 4;
					this.data = null;
					this.allowTies = true;
					this.setup();
					this.theme('auto');
					this.lang(navigator.language?.startsWith('id') ? 'id' : 'en');
				}
				setup() {
					const handlers = {
						add: () => this.add(),
						clear: () => this.clear(),
						calculate: () => this.calculate(),
						edit: () => this.display('input'),
						export: () => this.export(),
						import: () => elements.file.click()
					};
					Object.entries(handlers).forEach(([id, handler]) => elements[id].onclick = handler);
					elements.file.onchange = event => this.load(event.target.files[0]);
					elements.input.oninput = () => this.error();
					elements.language.onchange = event => this.lang(event.target.value);
					elements.theme.onchange = event => this.theme(event.target.value);
					elements.allowTies.onchange = event => {
						this.allowTies = event.target.checked;
						this.renderCompetitors();
					};
					elements.allowTies.checked = this.allowTies;
					document.onkeydown = event => this.key(event);
					elements.list.onclick = event => {
						const row = event.target.closest('.competitor-row');
						if (event.target.matches('.danger') && row) {
							this.remove(+row.dataset.id);
						}
					};
					elements.list.onchange = event => {
						const row = event.target.closest('.competitor-row');
						const comp = row && this.competitors.find(c => c.id === +row.dataset.id);
						if (comp) this.updateCompetitor(comp, event.target);
					};
				}
				key(event) {
					if (event.key !== 'Enter') return;

					if (event.ctrlKey || event.metaKey) {
						this.calculate();
						return;
					}

					if (event.target.matches('input') && event.target.closest('.competitor-row')) {
						event.preventDefault();
						const row = event.target.closest('.competitor-row');
						const comp = this.competitors.find(c => c.id === +row.dataset.id);
						if (comp) this.updateCompetitor(comp, event.target);
						this.focusNext(event.target, row);
					} else if (event.target.matches('#mainName, #allowTies')) {
						event.preventDefault();
						const firstInput = elements.list.firstElementChild?.querySelector('input');
						if (firstInput) {
							firstInput.focus();
						} else {
							elements.add.focus();
						}
					}
				}

				updateCompetitor(comp, target) {
					const val = target.value;
					if (target.classList.contains('name-input')) {
						comp.name = val;
					} else if (target.classList.contains('win-input')) {
						this.updateRate(comp, 'winRate', val, target);
					} else if (target.classList.contains('tie-input')) {
						this.updateRate(comp, 'tieRate', val, target);
					}
				}

				updateRate(comp, prop, value, target) {
					const num = value === '' ? '' : Math.max(0, Math.min(100, parseFloat(value) || 0));
					comp[prop] = num;
					if (target) target.value = num;
				}

				focusNext(target, row) {
					if (target.type === 'text') {
						target.nextElementSibling?.focus();
					} else if (target.classList.contains('win-input') && this.allowTies) {
						target.nextElementSibling?.focus();
					} else if (row.nextElementSibling) {
						row.nextElementSibling.querySelector('input')?.focus();
					} else {
						this.add();
					}
				}
				string(key) {
					return text[this.language]?.[key] ?? key;
				}
				format(value, options = {}) {
					return value.toLocaleString(this.language === 'id' ? 'id-ID' : 'en-US', options);
				}
				theme(themeName) {
					document.documentElement.className = themeName === 'auto' ? '' : themeName;
					elements.theme.value = themeName;
				}
				lang(language) {
					this.language = elements.language.value = document.documentElement.lang = language;
					Object.keys(text.en).forEach(key => {
						if (elements[key]) elements[key].textContent = this.string(key);
					});
					elements.headName.textContent = this.string('name');
					elements.headWin.textContent = this.string('winRatePlaceholder');
					elements.headTie.textContent = this.string('tieRatePlaceholder');
					[...elements.theme.options].forEach(option => option.textContent = this.string(option.value + 'Theme'));
					[['language', 'languageLabel'], ['theme', 'themeLabel']].forEach(([id, key]) => elements[id].setAttribute('aria-label', this.string(key)));
					this.renderCompetitors();
					if (!elements.results.classList.contains('hidden') && this.data) {
						this.renderResults();
					}
				}
				display(section) {
					['input', 'results'].forEach(id => elements[id].classList.toggle('hidden', id !== section));
					if (section === 'results') {
						elements.results.setAttribute('tabindex', '-1');
						elements.results.focus();
					} else {
						elements.mainName.focus();
					}
				}
				error(message) {
					elements.error.textContent = message || '';
					elements.error.classList.toggle('hidden', !message);
				}
				add() {
					this.error();
					this.competitors.push({ id: this.nextIndex++, name: '', winRate: '', tieRate: '' });
					this.renderCompetitors();
					elements.list.lastElementChild?.querySelector('input')?.focus();
				}
				clear() {
					if (confirm(this.string('clearConfirm'))) {
						this.competitors = [];
						this.renderCompetitors();
						this.add();
						this.error();
					}
				}
				remove(id) {
					this.error();
					const index = this.competitors.findIndex(c => c.id === id);
					this.competitors = this.competitors.filter(c => c.id !== id);
					this.renderCompetitors();
					const target = Math.min(index, this.competitors.length - 1);
					if (target >= 0) {
						elements.list.children[target]?.querySelector('.danger')?.focus();
					} else {
						elements.add.focus();
					}
				}
				renderCompetitors() {
					elements.headTie.classList.toggle('hidden', !this.allowTies);
					elements.list.innerHTML = this.competitors.map((comp, i) => 
						`<div class="competitor-row" data-id="${comp.id}">
							<input type="text" class="name-input" value="${escape(comp.name)}" placeholder="${this.string('competitorPlaceholder')}" aria-label="${this.string('competitorPlaceholder')} ${i + 1}">
							<input type="number" class="win-input" value="${comp.winRate}" placeholder="${this.string('winRatePlaceholder')}" min="0" max="100" step="0.1" aria-label="${this.string('winRatePlaceholder')} ${i + 1}">
							${this.allowTies ? `<input type="number" class="tie-input" value="${comp.tieRate}" placeholder="${this.string('tieRatePlaceholder')}" min="0" max="100" step="0.1" aria-label="${this.string('tieRatePlaceholder')} ${i + 1}">` : ''}
							<button class="danger" aria-label="${this.string('removeCompetitor')} ${i + 1}">×</button>
						</div>`
					).join('');
				}
				load(file) {
					const reader = new FileReader();
					reader.onload = event => {
						try {
							const rows = parseCSV(event.target.result);
							if (!rows.length) throw new Error();

							const header = rows[0];
							const find = regex => header.findIndex(cell => regex.test(cell));
							let nameIndex = find(/name|nama/i);
							let winIndex = find(/win|menang/i);
							let tieIndex = find(/tie|seri/i);

							if (nameIndex < 0 || winIndex < 0) {
								nameIndex = 0;
								winIndex = 1;
								const isAllNumbers = header.every(cell => /^\d+$/.test(cell.replace(/[.,]/g, '').trim()));
								if (isAllNumbers) {
									winIndex = header.findIndex(cell => /^\d+$/.test(cell.replace(/[.,]/g, '').trim()));
									nameIndex = 1 - winIndex;
								}
							}

							if (nameIndex < 0 || winIndex < 0) throw new Error();

							// Detect if the first row is actually data (headless CSV)
							// If keywords were found, it's definitely a header.
							// If not, checks if the determined 'win' column contains a number.
							const isWinNum = !isNaN(parseFloat((header[winIndex] || '').replace(',', '.')));
							const hasHeader = (find(/name|nama/i) >= 0 || find(/win|menang/i) >= 0) || !isWinNum;

							const competitors = (hasHeader ? rows.slice(1) : rows).map(cells => {
								if (!cells[nameIndex]) return null;
								const winRate = +((cells[winIndex] || '').replace(/[^\d.]/g, '')) || 0;
								const tieRate = tieIndex >= 0 ? (+((cells[tieIndex] || '').replace(/[^\d.]/g, '')) || 0) : 0;
								return {
									id: this.nextIndex++,
									name: cells[nameIndex],
									winRate,
									tieRate
								};
							}).filter(Boolean);

							if (!competitors.length) throw new Error();

							this.competitors = competitors;
							if (tieIndex >= 0) {
								this.allowTies = true;
								elements.allowTies.checked = true;
							}

							this.error();
							this.renderCompetitors();
							elements.file.value = '';
						} catch {
							this.error(this.string('alertImport'));
						}
					};
					if (file) reader.readAsText(file);
				}
				calculate() {
					this.error();
					const mainName = elements.mainName.value.trim() || 'Main';
					this.competitors = this.competitors.filter(c => c.name.trim() || c.winRate > 0 || c.tieRate > 0);
					this.renderCompetitors();

					const error = !this.competitors.length ? 'alertCompetitors' :
					              this.hasInvalidRates() ? 'alertInvalidRate' : null;

					if (error) {
						this.error(this.string(error));
					} else {
						this.performCalculation(mainName);
					}
				}

				hasInvalidRates() {
					return this.competitors.some(comp => {
						const tieRate = this.allowTies ? +comp.tieRate : 0;
						const winRate = +comp.winRate;
						return winRate < 0 || winRate > 100 || tieRate < 0 || tieRate > 100 || winRate + tieRate > 100;
					});
				}

				performCalculation(mainName) {
					const rawResults = this.competitors.map(comp => this.calculateRow(comp));
					const allRaw = [{ name: mainName, winRate: 50, tieRate: 0, effectiveScore: 0.5, rawElo: 0 }, ...rawResults];
					const avgElo = allRaw.reduce((sum, r) => sum + r.rawElo, 0) / allRaw.length;
					const adjustment = 1000 - avgElo;

					this.data = {
						mainName,
						results: allRaw.map(r => ({
							...r,
							eloRating: r.rawElo + adjustment,
							eloDiff: r.rawElo
						})).sort((a, b) => b.eloRating - a.eloRating),
						allowTies: this.allowTies
					};

					this.renderResults();
					this.display('results');
				}

				calculateRow(comp) {
					const tieRate = this.allowTies ? +comp.tieRate : 0;
					const effectiveScore = (+comp.winRate + tieRate * 0.5) / 100;

					const eloDiff = effectiveScore >= 1 ? 2000 :
					                effectiveScore <= 0 ? -2000 :
					                -400 * Math.log10(1 / effectiveScore - 1);

					return {
						name: comp.name.trim() || `Competitor ${comp.id}`,
						winRate: +comp.winRate,
						tieRate,
						effectiveScore,
						rawElo: eloDiff
					};
				}
				renderResults() {
					if (this.data) {
						const { results } = this.data;
						const maxElo = Math.max(...results.map(r => r.eloRating), 1);
						elements.resultsTable.innerHTML = `<h2>${this.string('resultsTitle')}</h2><p class="info">${this.string('infoText')}</p><table><thead><tr><th>${this.string('name')}</th><th>${this.string('winRate')}</th><th>${this.string('tieRate')}</th><th>${this.string('effectiveScore')}</th><th>${this.string('eloRating')}</th><th>${this.string('relativeStrength')}</th><th>${this.string('eloDifference')}</th></tr></thead><tbody>${results.map(result => `<tr><td><strong>${escape(result.name)}</strong></td><td>${this.format(result.winRate, { maximumFractionDigits: 1 })}%</td><td>${this.format(result.tieRate, { maximumFractionDigits: 1 })}%</td><td>${this.format(result.effectiveScore * 100, { maximumFractionDigits: 1 })}%</td><td><strong>${Math.round(result.eloRating)}</strong></td><td><div class="bar-container" title="${Math.round(result.eloRating)}"><div class="bar" style="width:${Math.max(0, result.eloRating / maxElo * 100)}%"></div></div></td><td>${result.eloDiff > 0 ? '+' : ''}${Math.round(result.eloDiff)}</td></tr>`).join('')}</tbody></table>`;
					}
				}
				export() {
					if (this.data) {
						const { results } = this.data;
						const headers = [this.string('name'), this.string('winRate'), this.string('tieRate'), this.string('effectiveScore'), this.string('eloRating'), this.string('eloDifference')].join(',');
						const csv = headers + '\n' + results.map(result => `"${result.name.replace(/"/g, '""')}",${result.winRate},${result.tieRate},${this.format(result.effectiveScore * 100, { minimumFractionDigits: 1, maximumFractionDigits: 1 })},${Math.round(result.eloRating)},${Math.round(result.eloDiff)}`).join('\n');
						Object.assign(document.createElement('a'), { href: URL.createObjectURL(new Blob([csv], { type: 'text/csv' })), download: `elo_ratings_${new Date().toISOString().slice(0, 19).replace(/[T:]/g, '-')}.csv` }).click();
					}
				}
			}
			new EloCalc();
		</script>
	</body>
</html>